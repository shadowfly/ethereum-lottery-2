# Ethereum Lottery Demo

Yet another prototype of a `Lottery` DApp which is currently just a renamed fork of [SampleCrowdsale.sol](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/examples/SampleCrowdsale.sol) obtained from the examples shared by [OpenZeppelin](https://github.com/OpenZeppelin/zeppelin-solidity) (an ERC20 token template).

To deploy the `Lottery` DApp on a truffle server, do the following:

	git clone https://github.com/strange-labs-uk/ethereum-lottery
	cd ethereum-lottery
	npm install -g truffle
	npm install
	truffle develop

In the `truffle(develop)>` console:

	deploy --reset

Now you can interact with the lottery contract. Lets send wei to the lottery DApp in exchange for tokens and simultaneous check the total number issued:
	
	lot = Lottery.deployed()
	lot.then(i=>i.buyTokens(web3.eth.coinbase,{value:10000,gas:1721975,gasPrice: 1000000})).then(i=>i.logs[1].args)

Check the token balance balance:
	
	tok = lot.token().then(address=>MintableToken.at(address))
	tok.then(instance=>instance.balanceOf(web3.eth.coinbase))

Run draw once the raffle time is up:

	lot.then(i=>i.runDraw()).then(i=>i.logs[0].args)

The best thing to do to ensure that the contract is functioning as expected seems to be to build unit tests into `test/Lottery.test.js` and run `test` inside `truffle(develop)>` console.

## Front-end

After you have the truffle contract deployed using the instructions above, now you can use the front-end to interact with functions from the deployed contract using a simple web interface. However, make sure you have [MetaMask](https://metamask.io) installed on your browser and have added one of the 10 accounts generated by truffle using the respective private key provided.

To serve it:

    cd frontend
    npm install
    npm start

Then browse to http://localhost:3000.

If you make changes to the contract that you want to propagate to the web interface, reset your deployed contract on the `truffle(develop)>` console and refresh the web page:
    
    deploy --reset



## second phase design

Overall code for contract:

```

Lottery {

  price int
  tickets [address]
  string secretKeyHash
  date start
  date end
  refunded bool

  constructor(secretKeyHash, ticketPrice, start, end) {
    this.secretKeyHash = secretKeyHash
    this.ticketPrice = ticketPrice
    this.start = start
    this.end = end
  }

  play(address, amount) {
    if(this.time > this.end) return
    if(this.time < this.start) return
    ticketsPurchased = amount / price
    if(ticketsPurchased < 1) return
    for(var i=0; i<ticketsPurchased; i++) {
      tickets.push(address)
    }
    returnRemainder()
  }

  draw(secretKey) {
    if(!owner) return
    if(this.time < this.end) return
    if(hash(secretKey) != this.secretKeyHash) return
    numPlayers = this.tickets.length
    useSecretNumber = combine(lastBlockHash, secretKey, numPlayers)
    winningIndex = int(useSecretNumber) % numPlayers
    winningAddress = this.tickets[winningIndex]
  }

  refund() {
    if(this.time < this.end + 1 day) return
    if(this.refunded) return
    for(var i=0; i<this.tickets.length; i++) {
      pay(this.tickets[i], this.price)
    }
    this.refunded = true
  }


}

```

